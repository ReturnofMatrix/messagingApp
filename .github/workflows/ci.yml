name: CI Pipeline

on:
  push:
    branches: [ main ]
  pull_request:

env:
  IMAGE_BASE: ghcr.io/returnofmatrix/messaging-server
  REGISTRY: ghcr.io

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract image metadata
        id: meta
        run: |
          IMAGE_TAG=${GITHUB_SHA::7}
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "image_full=${{ env.IMAGE_BASE }}:$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "Building image: ${{ env.IMAGE_BASE }}:$IMAGE_TAG"

      - name: Build Docker image
        working-directory: ./server
        run: |
          docker build \
            -t ${{ env.IMAGE_BASE }}:${{ steps.meta.outputs.image_tag }} \
            -t ${{ env.IMAGE_BASE }}:latest \
            .

      # ========== SECURITY SCANNING ==========
      
      - name: Run Trivy vulnerability scanner (blocking)
        id: trivy_scan
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: '${{ env.IMAGE_BASE }}:latest'
          format: 'table'
          exit-code: '1'
          ignore-unfixed: true
          vuln-type: 'os,library'
          severity: 'CRITICAL'
          timeout: '10m'
          trivyignores: '.trivyignore'
        continue-on-error: true

      - name: Run Trivy vulnerability scanner (detailed report)
        uses: aquasecurity/trivy-action@master
        if: always()
        with:
          image-ref: '${{ env.IMAGE_BASE }}:latest'
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL'
          ignore-unfixed: true
          trivyignores: '.trivyignore'

      - name: Upload Trivy results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Check Trivy scan results
        if: steps.trivy_scan.outcome == 'failure'
        run: |
          echo "❌ CRITICAL severity vulnerabilities found!"
          exit 1
      
      - name: Run Trivy config scanner on Dockerfile
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'config'
          scan-ref: 'server'
          format: 'table'
          exit-code: '0' 
          severity: 'CRITICAL'
        continue-on-error: true

      # ========== END SECURITY SCANNING ==========

      - name: Push Docker image to registry
        if: success()
        run: |
          echo "Pushing images to registry..."
          docker push ${{ env.IMAGE_BASE }}:${{ steps.meta.outputs.image_tag }}
          docker push ${{ env.IMAGE_BASE }}:latest
          echo "✓ Images pushed successfully"

      # ========== MINIKUBE DEPLOYMENT ==========

      - name: Start Minikube
        uses: medyagh/setup-minikube@latest
        with:
          driver: docker
          kubernetes-version: v1.28.3

      - name: Verify Minikube
        run: |
          kubectl cluster-info
          kubectl get nodes

      - name: Load Docker image into Minikube
        run: |
          echo "Loading image into Minikube..."
          minikube image load ${{ env.IMAGE_BASE }}:latest
          minikube image ls | grep messaging-server

      - name: Deploy PostgreSQL
        run: |
          kubectl apply -f k8s/postgres.yml
          kubectl wait --for=condition=ready pod -l app=postgres --timeout=120s
          echo "✓ PostgreSQL deployed"

      - name: Deploy Application
        run: |
          kubectl apply -f k8s/configmap.yml
          kubectl apply -f k8s/secret.yml
          kubectl apply -f k8s/deployment.yml
          kubectl apply -f k8s/service.yml
          echo "✓ Application manifests applied"

      - name: Wait for deployment
        run: |
          kubectl wait --for=condition=ready pod -l app=messaging-server --timeout=180s
          kubectl get pods
          kubectl get svc

      - name: Verify deployment
        run: |
          echo "=== Pods Status ==="
          kubectl get pods -o wide
          
          echo "=== Services ==="
          kubectl get svc
          
          echo "=== Deployment Status ==="
          kubectl get deployment messaging-server -o wide
          
          echo "=== Pod Logs ==="
          POD_NAME=$(kubectl get pod -l app=messaging-server -o jsonpath='{.items[0].metadata.name}')
          kubectl logs $POD_NAME --tail=50 || echo "⚠️ Could not fetch logs"

      - name: Test health endpoint
        run: |
          POD_NAME=$(kubectl get pod -l app=messaging-server -o jsonpath='{.items[0].metadata.name}')
          kubectl exec $POD_NAME -- curl -sf http://localhost:4000/health
          echo "✓ Health check passed"

      # ========== END MINIKUBE DEPLOYMENT ==========

      - name: Generate build summary
        if: always()
        run: |
          echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag:** ${{ steps.meta.outputs.image_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image:** ${{ steps.meta.outputs.image_full }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Security Scan:** ✅ Passed" >> $GITHUB_STEP_SUMMARY
          echo "- **Kubernetes Test:** ✅ Deployed to Minikube" >> $GITHUB_STEP_SUMMARY

      - name: Clean up
        if: always()
        run: |
          echo "Minikube cluster will be destroyed automatically"
          echo "✓ Cleanup completed"